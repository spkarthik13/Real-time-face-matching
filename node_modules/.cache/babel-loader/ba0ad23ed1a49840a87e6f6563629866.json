{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { BoundingBox } from '../classes/BoundingBox';\nimport { ObjectDetection } from '../classes/ObjectDetection';\nimport { convLayer } from '../common';\nimport { toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { sigmoid } from '../ops';\nimport { nonMaxSuppression } from '../ops/nonMaxSuppression';\nimport { normalize } from '../ops/normalize';\nimport { validateConfig } from './config';\nimport { convWithBatchNorm } from './convWithBatchNorm';\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { leaky } from './leaky';\nimport { TinyYolov2Options } from './TinyYolov2Options';\n\nvar TinyYolov2 =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TinyYolov2, _super);\n\n  function TinyYolov2(config) {\n    var _this = _super.call(this, 'TinyYolov2') || this;\n\n    validateConfig(config);\n    _this._config = config;\n    return _this;\n  }\n\n  Object.defineProperty(TinyYolov2.prototype, \"config\", {\n    get: function get() {\n      return this._config;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2.prototype, \"withClassScores\", {\n    get: function get() {\n      return this.config.withClassScores || this.config.classes.length > 1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2.prototype, \"boxEncodingSize\", {\n    get: function get() {\n      return 5 + (this.withClassScores ? this.config.classes.length : 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TinyYolov2.prototype.runTinyYolov2 = function (x, params) {\n    var out = convWithBatchNorm(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = convWithBatchNorm(out, params.conv6);\n    out = convWithBatchNorm(out, params.conv7);\n    return convLayer(out, params.conv8, 'valid', false);\n  };\n\n  TinyYolov2.prototype.runMobilenet = function (x, params) {\n    var out = this.config.isFirstLayerConv2d ? leaky(convLayer(x, params.conv0, 'valid', false)) : depthwiseSeparableConv(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out;\n    out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out;\n    return convLayer(out, params.conv8, 'valid', false);\n  };\n\n  TinyYolov2.prototype.forwardInput = function (input, inputSize) {\n    var _this = this;\n\n    var params = this.params;\n\n    if (!params) {\n      throw new Error('TinyYolov2 - load model before inference');\n    }\n\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(inputSize, false).toFloat();\n      batchTensor = _this.config.meanRgb ? normalize(batchTensor, _this.config.meanRgb) : batchTensor;\n      batchTensor = batchTensor.div(tf.scalar(256));\n      return _this.config.withSeparableConvs ? _this.runMobilenet(batchTensor, params) : _this.runTinyYolov2(batchTensor, params);\n    });\n  };\n\n  TinyYolov2.prototype.forward = function (input, inputSize) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_b.sent(), inputSize])];\n\n          case 2:\n            return [2\n            /*return*/\n            , _b.sent()];\n        }\n      });\n    });\n  };\n\n  TinyYolov2.prototype.detect = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;\n\n      var _this = this;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = new TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            netInput = _b.sent();\n            return [4\n            /*yield*/\n            , this.forwardInput(netInput, inputSize)];\n\n          case 2:\n            out = _b.sent();\n            out0 = tf.tidy(function () {\n              return tf.unstack(out)[0].expandDims();\n            });\n            inputDimensions = {\n              width: netInput.getInputWidth(0),\n              height: netInput.getInputHeight(0)\n            };\n            results = this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold);\n            out.dispose();\n            out0.dispose();\n            boxes = results.map(function (res) {\n              return res.box;\n            });\n            scores = results.map(function (res) {\n              return res.score;\n            });\n            classScores = results.map(function (res) {\n              return res.classScore;\n            });\n            classNames = results.map(function (res) {\n              return _this.config.classes[res.label];\n            });\n            indices = nonMaxSuppression(boxes.map(function (box) {\n              return box.rescale(inputSize);\n            }), scores, this.config.iouThreshold, true);\n            detections = indices.map(function (idx) {\n              return new ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);\n            });\n            return [2\n            /*return*/\n            , detections];\n        }\n      });\n    });\n  };\n\n  TinyYolov2.prototype.getDefaultModelName = function () {\n    return '';\n  };\n\n  TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return extractParamsFromWeigthMap(weightMap, this.config);\n  };\n\n  TinyYolov2.prototype.extractParams = function (weights) {\n    var filterSizes = this.config.filterSizes || TinyYolov2.DEFAULT_FILTER_SIZES;\n    var numFilters = filterSizes ? filterSizes.length : undefined;\n\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\n      throw new Error(\"TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found \" + numFilters + \" filterSizes in config\");\n    }\n\n    return extractParams(weights, this.config, this.boxEncodingSize, filterSizes);\n  };\n\n  TinyYolov2.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {\n    var _this = this;\n\n    var width = inputBlobDimensions.width,\n        height = inputBlobDimensions.height;\n    var inputSize = Math.max(width, height);\n    var correctionFactorX = inputSize / width;\n    var correctionFactorY = inputSize / height;\n    var numCells = outputTensor.shape[1];\n    var numBoxes = this.config.anchors.length;\n\n    var _a = tf.tidy(function () {\n      var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);\n      var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\n      var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\n      var classScores = _this.withClassScores ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3) : tf.scalar(0);\n      return [boxes, scores, classScores];\n    }),\n        boxesTensor = _a[0],\n        scoresTensor = _a[1],\n        classScoresTensor = _a[2];\n\n    var results = [];\n\n    for (var row = 0; row < numCells; row++) {\n      for (var col = 0; col < numCells; col++) {\n        for (var anchor = 0; anchor < numBoxes; anchor++) {\n          var score = sigmoid(scoresTensor.get(row, col, anchor, 0));\n\n          if (!scoreThreshold || score > scoreThreshold) {\n            var ctX = (col + sigmoid(boxesTensor.get(row, col, anchor, 0))) / numCells * correctionFactorX;\n            var ctY = (row + sigmoid(boxesTensor.get(row, col, anchor, 1))) / numCells * correctionFactorY;\n            var width_1 = Math.exp(boxesTensor.get(row, col, anchor, 2)) * this.config.anchors[anchor].x / numCells * correctionFactorX;\n            var height_1 = Math.exp(boxesTensor.get(row, col, anchor, 3)) * this.config.anchors[anchor].y / numCells * correctionFactorY;\n            var x = ctX - width_1 / 2;\n            var y = ctY - height_1 / 2;\n            var pos = {\n              row: row,\n              col: col,\n              anchor: anchor\n            };\n\n            var _b = this.withClassScores ? this.extractPredictedClass(classScoresTensor, pos) : {\n              classScore: 1,\n              label: 0\n            },\n                classScore = _b.classScore,\n                label = _b.label;\n\n            results.push(tslib_1.__assign({\n              box: new BoundingBox(x, y, x + width_1, y + height_1),\n              score: score,\n              classScore: score * classScore,\n              label: label\n            }, pos));\n          }\n        }\n      }\n    }\n\n    boxesTensor.dispose();\n    scoresTensor.dispose();\n    classScoresTensor.dispose();\n    return results;\n  };\n\n  TinyYolov2.prototype.extractPredictedClass = function (classesTensor, pos) {\n    var row = pos.row,\n        col = pos.col,\n        anchor = pos.anchor;\n    return Array(this.config.classes.length).fill(0).map(function (_, i) {\n      return classesTensor.get(row, col, anchor, i);\n    }).map(function (classScore, label) {\n      return {\n        classScore: classScore,\n        label: label\n      };\n    }).reduce(function (max, curr) {\n      return max.classScore > curr.classScore ? max : curr;\n    });\n  };\n\n  TinyYolov2.DEFAULT_FILTER_SIZES = [3, 16, 32, 64, 128, 256, 512, 1024, 1024];\n  return TinyYolov2;\n}(NeuralNetwork);\n\nexport { TinyYolov2 };","map":null,"metadata":{},"sourceType":"module"}